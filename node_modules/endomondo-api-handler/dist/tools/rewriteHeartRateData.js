'use strict';

var mathjs = require('mathjs');
var luxon = require('luxon');

/**
 * Rewrite altitude or hr of points based on updater.
 *
 * @param workout
 * @param type
 * @param getNewValue
 * @returns {Workout}
 */
function rewriteWorkoutData(workout, type, getNewValue) {
  const newPoints = workout.getPoints().map(point => {
    const newValue = getNewValue(point);

    if (type === 'altitude') {
      return point.setAltitude(newValue ? mathjs.unit(newValue, 'm') : undefined);
    }

    if (type === 'hr') {
      return point.setHeartRate(newValue);
    }

    return point.setCadence(newValue);
  });
  return workout.setPoints(newPoints);
}

var rewriteTimeData = ((point, data) => {
  const time = point.getTime();

  if (!time) {
    return undefined;
  }

  const valueOfTime = time.valueOf();
  const nearest = data.sort((a, b) => {
    return Math.abs(valueOfTime - a.time) - Math.abs(valueOfTime - b.time);
  })[0];

  if (time.diff(luxon.DateTime.fromMillis(nearest.time), ['milliseconds']).as('seconds') > 15) {
    return undefined;
  }

  return nearest.value;
});

function rewriteHeartRateData(workout, HrData) {
  return rewriteWorkoutData(workout, 'hr', point => {
    return rewriteTimeData(point, HrData.map(item => {
      return {
        value: item.hr,
        time: item.time.valueOf()
      };
    }));
  });
}

module.exports = rewriteHeartRateData;
