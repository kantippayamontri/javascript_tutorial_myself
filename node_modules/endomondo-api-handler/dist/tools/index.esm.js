import { unit } from 'mathjs';
import { DateTime } from 'luxon';

/**
 * Create new workout and delete old one. It is only way how to update points.
 *
 * @param workout
 * @param api
 * @param mobileApi
 * @returns Workout with updated id.
 */
async function replaceWorkout(workout, api, mobileApi) {
  const newWorkoutId = await mobileApi.createWorkout(workout);
  const newWorkout = workout.setId(newWorkoutId);
  newWorkout.getHashtags().forEach(hashtag => {
    api.addHashtag(hashtag, newWorkoutId);
  });
  await api.editWorkout(newWorkout);
  await api.deleteWorkout(workout.getId());
  return newWorkout;
}

/**
 * Recalculate total ascent and descent.
 *
 * @param workout
 * @returns {Workout}
 */
function recalculateAscentDescent(workout) {
  let ascent = 0;
  let descent = 0;
  let previusPoint = null;
  workout.getPoints().forEach(point => {
    if (!previusPoint) {
      previusPoint = point;
      return;
    }

    const altitude = point.getAltitude();
    const previusAltitude = previusPoint.getAltitude();

    if (altitude == null) {
      return;
    }

    if (previusAltitude == null) {
      previusPoint = point;
      return;
    }

    const diff = altitude.toNumber('m') - previusAltitude.toNumber('m');

    if (diff > 0) {
      ascent += diff;
    } else {
      descent -= diff;
    }

    previusPoint = point;
  });
  return workout.setAscent(unit(ascent, 'm')).setDescent(unit(descent, 'm'));
}

/**
 * Rewrite altitude or hr of points based on updater.
 *
 * @param workout
 * @param type
 * @param getNewValue
 * @returns {Workout}
 */
function rewriteWorkoutData(workout, type, getNewValue) {
  const newPoints = workout.getPoints().map(point => {
    const newValue = getNewValue(point);

    if (type === 'altitude') {
      return point.setAltitude(newValue ? unit(newValue, 'm') : undefined);
    }

    if (type === 'hr') {
      return point.setHeartRate(newValue);
    }

    return point.setCadence(newValue);
  });
  return workout.setPoints(newPoints);
}

function normalizeLocation(loc) {
  if (loc == null) {
    return loc;
  }

  return Math.round(loc * 10 ** 6) / 10 ** 6;
}

function rewriteAltitudeData(workout, altitudeData) {
  const newWorkout = rewriteWorkoutData(workout, 'altitude', point => {
    const elevation = altitudeData.find(item => {
      return normalizeLocation(item.location.lat) === normalizeLocation(point.getLatitude()) && normalizeLocation(item.location.lng) === normalizeLocation(point.getLongitude());
    });
    return elevation ? elevation.elevation : undefined;
  }); // in finish, recalculate ascent and descent

  return recalculateAscentDescent(newWorkout);
}

var rewriteTimeData = ((point, data) => {
  const time = point.getTime();

  if (!time) {
    return undefined;
  }

  const valueOfTime = time.valueOf();
  const nearest = data.sort((a, b) => {
    return Math.abs(valueOfTime - a.time) - Math.abs(valueOfTime - b.time);
  })[0];

  if (time.diff(DateTime.fromMillis(nearest.time), ['milliseconds']).as('seconds') > 15) {
    return undefined;
  }

  return nearest.value;
});

function rewriteHeartRateData(workout, HrData) {
  return rewriteWorkoutData(workout, 'hr', point => {
    return rewriteTimeData(point, HrData.map(item => {
      return {
        value: item.hr,
        time: item.time.valueOf()
      };
    }));
  });
}

function rewriteCadenceData(workout, cadenceData) {
  return rewriteWorkoutData(workout, 'cadence', point => {
    return rewriteTimeData(point, cadenceData.map(item => {
      return {
        value: item.cadence,
        time: item.time.valueOf()
      };
    }));
  });
}

export { replaceWorkout, rewriteAltitudeData, rewriteCadenceData, rewriteHeartRateData };
