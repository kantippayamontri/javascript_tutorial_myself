'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var zlib = require('zlib');
var restApiHandler = require('rest-api-handler');

class EndomondoException extends Error {
  constructor(message) {
    super("Endomondo Error: " + message);
  }

}

/**
 * Endomondo API Exception
 */

class EndomondoApiException extends EndomondoException {
  /**
   * Constructor.
   */
  constructor(response) {
    super(JSON.stringify(response.data));

    _defineProperty(this, "response", void 0);

    this.response = response;
  }

  getResponse() {
    return this.response;
  }

  getRequest() {
    return this.response.request;
  }

}

class EndomondoAuthException extends EndomondoApiException {}

const ENDOMONDO_MOBILE_URL = 'https://api.mobile.endomondo.com/mobile';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function processStringResponse(response) {
  const data = {};
  response.split('\n').map(item => item.split('=')).filter(item => item.length === 2).forEach(item => {
    const [key, value] = item;
    data[key] = value;
  });
  return data;
}

function gzipRequestBody(body) {
  return new Promise((resolve, reject) => {
    zlib.gzip(body, (error, buffer) => {
      if (error) {
        reject(error);
        return;
      }

      resolve(buffer);
    });
  });
}

class MobileApi extends restApiHandler.Api {
  constructor() {
    super(ENDOMONDO_MOBILE_URL, [async (response, request) => {
      const contentType = response.headers.get('content-type');
      const toResponse = {
        data: contentType && contentType.includes('json') ? await response.json() : await response.text(),
        status: response.status,
        source: response,
        request
      };

      if (typeof toResponse.data === 'object' && toResponse.data.error || !response.ok) {
        if (toResponse.data.error && toResponse.data.error.type === 'AUTH_FAILED') {
          throw new EndomondoAuthException(toResponse);
        }

        throw new EndomondoApiException(toResponse);
      }

      return toResponse;
    }], {
      'Content-Type': 'application/octet-stream',
      'User-Agent': 'Dalvik/1.4.0 (Linux; U; Android 4.1; GT-B5512 Build/GINGERBREAD)'
    });

    _defineProperty(this, "authToken", void 0);

    _defineProperty(this, "userId", void 0);

    this.authToken = null;
    this.userId = null;
  }

  getUserToken() {
    return this.authToken;
  }

  setUserToken(authToken) {
    this.authToken = authToken;
  }

  getUserId() {
    return this.userId;
  }

  setUserId(id) {
    this.userId = id;
  }

  async login(email, password) {
    const options = {
      email,
      password,
      country: '',
      deviceId: null,
      action: 'PAIR'
    };
    const response = await this.post("auth" + restApiHandler.Api.convertParametersToUrl(options));
    const decoded = processStringResponse(response.data);

    if (!decoded.userId || !decoded.authToken) {
      throw new EndomondoException("User id and token was not found in response: " + response.data);
    }

    const {
      userId,
      authToken
    } = decoded;
    this.setUserId(Number(userId));
    this.setUserToken(authToken);
    return authToken;
  }

  async getProfile() {
    return this.get('api/workouts', {
      authToken: this.getUserToken()
    });
  }
  /**
   * Create Endomondo workout.
   *
   * @param workout
   * @returns {Promise<number>} return id of new workout
   */


  async createWorkout(workout) {
    const options = {
      workoutId: "-" + 'XXXXXXXXXXXXXXXX'.split('X').map(() => {
        return Math.floor(Math.random() * 9);
      }).join(''),
      duration: workout.getDuration().as('seconds'),
      sport: workout.getTypeId(),
      extendedResponse: true,
      gzip: true,
      authToken: this.getUserToken()
    };
    const gzippedBody = await gzipRequestBody(workout.getPoints().map(point => point.toString()).join('\n'));
    const response = await this.request("track" + restApiHandler.Api.convertParametersToUrl(options), 'POST', {
      body: gzippedBody
    });

    if (response.data.trim() === 'AUTH_FAILED') {
      throw new EndomondoAuthException(response);
    }

    const workoutId = processStringResponse(response.data)['workout.id'];

    if (!workoutId) {
      throw new EndomondoException('Error while creating workout. Endomondo did not returned workout id.');
    }

    const numberedWorkoutId = Number(workoutId);
    await this.updateWorkout(workout.setId(numberedWorkoutId));
    return numberedWorkoutId;
  }

  async updateWorkout(workout) {
    const distance = workout.getDistance();

    const data = _objectSpread({
      duration: workout.getDuration().as('seconds'),
      sport: workout.getTypeId(),
      start_time: workout.getStart().toUTC().toFormat(MobileApi.dataFormat),
      end_time: workout.getStart().toUTC().toFormat(MobileApi.dataFormat),
      extendedResponse: true,
      gzip: true
    }, distance != null ? {
      distance: distance.toNumber('km')
    } : {}, {}, workout.getCalories() != null ? {
      calories: workout.getCalories()
    } : {}, {}, workout.getMessage() != null ? {
      message: workout.getMessage()
    } : {}, {}, workout.getMapPrivacy() != null ? {
      privacy_map: workout.getMapPrivacy()
    } : {}, {}, workout.getWorkoutPrivacy() != null ? {
      privacy_workout: workout.getWorkoutPrivacy()
    } : {});

    const options = {
      workoutId: workout.getId(),
      userId: this.getUserId(),
      gzip: true,
      authToken: this.getUserToken()
    };
    return this.request("api/workout/post" + restApiHandler.Api.convertParametersToUrl(options), 'POST', {
      body: await gzipRequestBody(JSON.stringify(data))
    });
  }

}

_defineProperty(MobileApi, "dataFormat", 'yyyy-MM-dd HH:mm:ss \'UTC\'');

module.exports = MobileApi;
