import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { parseUrl } from 'query-string';
import { DefaultResponseProcessor, Api as Api$1 } from 'rest-api-handler';
import CookieApi from 'cookie-api-handler';
import { DateTime, Duration } from 'luxon';
import { unit } from 'mathjs';
import { Point as Point$2, Workout as Workout$1 } from 'fitness-models';
import { GarminBuilder, buildGPX } from 'gpx-builder';
import { gzip } from 'zlib';

const RUNNING = 0;
const CYCLING_TRANSPORT = 1;
const CYCLING_SPORT = 2;
const MOUNTAIN_BIKINGS = 3;
const SKATING = 4;
const ROLLER_SKIING = 5;
const SKIING_CROSS_COUNTRY = 6;
const SKIING_DOWNHILL = 7;
const SNOWBOARDING = 8;
const KAYAKING = 9;
const KITE_SURFING = 10;
const ROWING = 11;
const SAILING = 12;
const WINDSURFING = 13;
const FINTESS_WALKING = 14;
const GOLFING = 15;
const HIKING = 16;
const ORIENTEERING = 17;
const WALKING = 18;
const RIDING = 19;
const SWIMMING = 20;
const CYCLING_INDOOR = 21;
const OTHER = 22;
const AEROBICS = 23;
const BADMINTON = 24;
const BASEBALL = 25;
const BASKETBALL = 26;
const BOXING = 27;
const CLIMBING_STAIRS = 28;
const CRICKET = 29;
const ELLIPTICAL_TRAINING = 30;
const DANCING = 31;
const FENCING = 32;
const FOOTBALL_AMERICAN = 33;
const FOOTBALL_RUGBY = 34;
const FOOTBALL_SOCCER = 35;
const HANDBALL = 36;
const HOCKEY = 37;
const PILATES = 38;
const POLO = 39;
const SCUBA_DIVING = 40;
const SQUASH = 41;
const TABLE_TENIS = 42;
const TENNIS = 43;
const VOLEYBALL_BEACH = 44;
const VOLEYBALL_INDOOR = 45;
const WEIGHT_TRAINING = 46;
const YOGA = 47;
const MARTINAL_ARTS = 48;
const GYMNASTICS = 49;
const STEP_COUNTER = 50;
const CIRKUIT_TRAINING = 87;
const RUNNING_TREADMILL = 88;
const SKATEBOARDING = 89;
const SURFING = 90;
const SNOWSHOEING = 91;
const WHEELCHAIR = 92;
const CLIMBING = 93;
const WALKING_TREADMILL = 94;
const KICK_SCOOTER = 95;
const STAND_UP_PADDLING = 96;
const TRAIL_RUNNING = 97;
const ROWING_INDOORS = 98;
const FLOORBALL = 99;
const ICE_SKATING = 100;
const SKI_TOURING = 101;
const ROPE_JUMPING = 102;
const STRETCHING = 103;
const CANICROSS = 104;
const PADDLE_TENNIS = 105;
const PARAGLIDING = 106;

var SPORT = ({
    __proto__: null,
    RUNNING: RUNNING,
    CYCLING_TRANSPORT: CYCLING_TRANSPORT,
    CYCLING_SPORT: CYCLING_SPORT,
    MOUNTAIN_BIKINGS: MOUNTAIN_BIKINGS,
    SKATING: SKATING,
    ROLLER_SKIING: ROLLER_SKIING,
    SKIING_CROSS_COUNTRY: SKIING_CROSS_COUNTRY,
    SKIING_DOWNHILL: SKIING_DOWNHILL,
    SNOWBOARDING: SNOWBOARDING,
    KAYAKING: KAYAKING,
    KITE_SURFING: KITE_SURFING,
    ROWING: ROWING,
    SAILING: SAILING,
    WINDSURFING: WINDSURFING,
    FINTESS_WALKING: FINTESS_WALKING,
    GOLFING: GOLFING,
    HIKING: HIKING,
    ORIENTEERING: ORIENTEERING,
    WALKING: WALKING,
    RIDING: RIDING,
    SWIMMING: SWIMMING,
    CYCLING_INDOOR: CYCLING_INDOOR,
    OTHER: OTHER,
    AEROBICS: AEROBICS,
    BADMINTON: BADMINTON,
    BASEBALL: BASEBALL,
    BASKETBALL: BASKETBALL,
    BOXING: BOXING,
    CLIMBING_STAIRS: CLIMBING_STAIRS,
    CRICKET: CRICKET,
    ELLIPTICAL_TRAINING: ELLIPTICAL_TRAINING,
    DANCING: DANCING,
    FENCING: FENCING,
    FOOTBALL_AMERICAN: FOOTBALL_AMERICAN,
    FOOTBALL_RUGBY: FOOTBALL_RUGBY,
    FOOTBALL_SOCCER: FOOTBALL_SOCCER,
    HANDBALL: HANDBALL,
    HOCKEY: HOCKEY,
    PILATES: PILATES,
    POLO: POLO,
    SCUBA_DIVING: SCUBA_DIVING,
    SQUASH: SQUASH,
    TABLE_TENIS: TABLE_TENIS,
    TENNIS: TENNIS,
    VOLEYBALL_BEACH: VOLEYBALL_BEACH,
    VOLEYBALL_INDOOR: VOLEYBALL_INDOOR,
    WEIGHT_TRAINING: WEIGHT_TRAINING,
    YOGA: YOGA,
    MARTINAL_ARTS: MARTINAL_ARTS,
    GYMNASTICS: GYMNASTICS,
    STEP_COUNTER: STEP_COUNTER,
    CIRKUIT_TRAINING: CIRKUIT_TRAINING,
    RUNNING_TREADMILL: RUNNING_TREADMILL,
    SKATEBOARDING: SKATEBOARDING,
    SURFING: SURFING,
    SNOWSHOEING: SNOWSHOEING,
    WHEELCHAIR: WHEELCHAIR,
    CLIMBING: CLIMBING,
    WALKING_TREADMILL: WALKING_TREADMILL,
    KICK_SCOOTER: KICK_SCOOTER,
    STAND_UP_PADDLING: STAND_UP_PADDLING,
    TRAIL_RUNNING: TRAIL_RUNNING,
    ROWING_INDOORS: ROWING_INDOORS,
    FLOORBALL: FLOORBALL,
    ICE_SKATING: ICE_SKATING,
    SKI_TOURING: SKI_TOURING,
    ROPE_JUMPING: ROPE_JUMPING,
    STRETCHING: STRETCHING,
    CANICROSS: CANICROSS,
    PADDLE_TENNIS: PADDLE_TENNIS,
    PARAGLIDING: PARAGLIDING
});

var LIST_OF_SPORT_NAMES = {
  [RUNNING]: 'Running',
  [CYCLING_TRANSPORT]: 'Cycling, transport',
  [CYCLING_SPORT]: 'Cycling, sport',
  [MOUNTAIN_BIKINGS]: 'Mountain biking',
  [SKATING]: 'Skating',
  [ROLLER_SKIING]: 'Roller skiing',
  [SKIING_CROSS_COUNTRY]: 'Skiing, cross country',
  [SKIING_DOWNHILL]: 'Skiing, downhill',
  [SNOWBOARDING]: 'Snowboarding',
  [KAYAKING]: 'Kayaking',
  [KITE_SURFING]: 'Kite surfing',
  [ROWING]: 'Rowing',
  [SAILING]: 'Sailing',
  [WINDSURFING]: 'Windsurfing',
  [FINTESS_WALKING]: 'Fitness walking',
  [GOLFING]: 'Golfing',
  [HIKING]: 'Hiking',
  [ORIENTEERING]: 'Orienteering',
  [WALKING]: 'Walking',
  [RIDING]: 'Riding',
  [SWIMMING]: 'Swimming',
  [CYCLING_INDOOR]: 'Cycling, Indoor',
  [OTHER]: 'Other',
  [AEROBICS]: 'Aerobics',
  [BADMINTON]: 'Badminton',
  [BASEBALL]: 'Baseball',
  [BASKETBALL]: 'Basketball',
  [BOXING]: 'Boxing',
  [CLIMBING_STAIRS]: 'Climbing stairs',
  [CRICKET]: 'Cricket',
  [ELLIPTICAL_TRAINING]: 'Elliptical training',
  [DANCING]: 'Dancing',
  [FENCING]: 'Fencing',
  [FOOTBALL_AMERICAN]: 'Football, American',
  [FOOTBALL_RUGBY]: 'Football, rugby',
  [FOOTBALL_SOCCER]: 'Football, soccer',
  [HANDBALL]: 'Handball',
  [HOCKEY]: 'Hockey',
  [PILATES]: 'Pilates',
  [POLO]: 'Polo',
  [SCUBA_DIVING]: 'Scuba diving',
  [SQUASH]: 'Squash',
  [TABLE_TENIS]: 'Table tennis',
  [TENNIS]: 'Tennis',
  [VOLEYBALL_BEACH]: 'Volleyball, beach',
  [VOLEYBALL_INDOOR]: 'Volleyball, indoor',
  [WEIGHT_TRAINING]: 'Weight training',
  [YOGA]: 'Yoga',
  [MARTINAL_ARTS]: 'Martial arts',
  [GYMNASTICS]: 'Gymnastics',
  [STEP_COUNTER]: 'Step counter',
  [CIRKUIT_TRAINING]: 'Circuit Training',
  [SKATEBOARDING]: 'Skateboarding',
  [CLIMBING]: 'Climbing',
  [KICK_SCOOTER]: 'Kick scooter',
  [CANICROSS]: 'Canicross',
  [FLOORBALL]: 'Floorball',
  [ICE_SKATING]: 'Ice skating',
  [RUNNING_TREADMILL]: 'Running (Treadmill)',
  [SURFING]: 'Surfing',
  [SNOWSHOEING]: 'Showshoeing',
  [WHEELCHAIR]: 'Wheelchair',
  [WALKING_TREADMILL]: 'Walking (Treadmill)',
  [STAND_UP_PADDLING]: 'Stand up paddling',
  [TRAIL_RUNNING]: 'Trail running',
  [ROWING_INDOORS]: 'Rowing (indoors)',
  [SKI_TOURING]: 'Ski touring',
  [ROPE_JUMPING]: 'Rope jumping',
  [STRETCHING]: 'Stretching',
  [PADDLE_TENNIS]: 'Paddle tennis',
  [PARAGLIDING]: 'Paragliding'
};

const ENDOMONDO_URL = 'https://www.endomondo.com';
const ENDOMONDO_MOBILE_URL = 'https://api.mobile.endomondo.com/mobile';

class EndomondoException extends Error {
  constructor(message) {
    super("Endomondo Error: " + message);
  }

}

/**
 * Endomondo API Exception
 */

class EndomondoApiException extends EndomondoException {
  /**
   * Constructor.
   */
  constructor(response) {
    super(JSON.stringify(response.data));

    _defineProperty(this, "response", void 0);

    this.response = response;
  }

  getResponse() {
    return this.response;
  }

  getRequest() {
    return this.response.request;
  }

}

class EndomondoAuthException extends EndomondoApiException {}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
class Point extends Point$2 {
  constructor(options) {
    super(options);

    _defineProperty(this, "instruction", void 0);

    this.instruction = options.instruction;
  }

  static fromApi(point, timezone) {
    const {
      distance,
      altitude,
      sensor_data,
      time
    } = point;
    return new Point(_objectSpread({
      time: time ? DateTime.fromISO(time, {
        zone: timezone
      }) : undefined,
      instruction: point.instruction,
      latitude: point.latitude,
      longitude: point.longitude,
      duration: Duration.fromObject({
        seconds: point.duration
      }),
      distance: distance != null ? unit(distance, 'km') : undefined,
      altitude: altitude != null ? unit(altitude, 'm') : undefined
    }, sensor_data ? {
      speed: sensor_data.speed != null ? unit(sensor_data.speed, 'km/h') : undefined,
      hr: sensor_data.heart_rate,
      cadence: sensor_data.cadence
    } : {}));
  } // eslint-disable-next-line complexity


  static get(time, latitude, longitude, {
    instruction,
    distance,
    duration,
    speed,
    altitude,
    cadence,
    hr
  } = {}) {
    return new Point(_objectSpread({
      time: time instanceof DateTime ? time : DateTime.fromISO(time, {
        setZone: true
      }),
      latitude,
      longitude,
      hr,
      instruction,
      cadence,
      distance: typeof distance === 'number' ? unit(distance, 'km') : distance,
      altitude: typeof altitude === 'number' ? unit(altitude, 'm') : altitude,
      speed: typeof speed === 'number' ? unit(speed, 'km/h') : speed
    }, duration instanceof Duration ? {
      duration
    } : {}, {}, typeof duration === 'number' ? {
      duration: Duration.fromObject({
        seconds: duration
      })
    } : {}, {}, !(duration instanceof Duration) && typeof duration === 'object' ? {
      duration: Duration.fromObject(duration)
    } : {}));
  }

  clone(extension = {}) {
    return new Point(_objectSpread({}, this.toObject(), {}, extension));
  }

  getInstruction() {
    return this.instruction;
  }

  setInstruction(instruction) {
    return this.clone({
      instruction
    });
  }

  setTime(time) {
    return this.clone({
      time
    });
  }

  setLatitude(latitude) {
    return this.clone({
      latitude
    });
  }

  setLongitude(longitude) {
    return this.clone({
      longitude
    });
  }

  setAltitude(altitude) {
    return this.clone({
      altitude
    });
  }

  setDistance(distance) {
    return this.clone({
      distance
    });
  }

  setSpeed(speed) {
    return this.clone({
      speed
    });
  }

  setHeartRate(hr) {
    return this.clone({
      hr
    });
  }

  setCadence(cadence) {
    return this.clone({
      cadence
    });
  }

  setDuration(duration) {
    return this.clone({
      duration
    });
  }

  toObject() {
    return _objectSpread({}, super.toObject(), {
      instruction: this.getInstruction()
    });
  }

  toString() {
    const distance = this.getDistance();
    const altitude = this.getAltitude();
    const speed = this.getSpeed();
    const time = this.getTime();
    return [time != null ? time.toUTC().toFormat('yyyy-MM-dd HH:mm:ss \'UTC\'') : undefined, this.getInstruction(), this.getLatitude(), this.getLongitude(), distance != null ? distance.toNumber('km') : undefined, speed != null ? speed.toNumber('km/h') : undefined, altitude != null ? altitude.toNumber('m') : undefined, this.getHeartRate(), this.getCadence(), ''].map(item => {
      return item == null ? '' : item;
    }).join(';');
  }

}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
const {
  Point: Point$1,
  Metadata,
  Person,
  Link,
  Track,
  Segment
} = GarminBuilder.MODELS; // @ts-ignore

function convertPoints(points) {
  return points.map(point => {
    return point.toObject();
  }).map(point => {
    const {
      altitude,
      cadence,
      hr,
      latitude,
      longitude,
      speed,
      time
    } = point;

    if (!latitude || !longitude) {
      return null;
    }

    return new Point$1(latitude, longitude, {
      time: time ? time.toJSDate() : undefined,
      hr,
      cad: cadence,
      ele: altitude ? altitude.toNumber('m') : undefined,
      speed: speed ? speed.toNumber('m/s') : undefined
    });
  }).filter(item => item !== null);
}

var workoutGPXExporter = (workout => {
  const workoutId = workout.getId();
  const source = workout.getSource();
  const authorId = source && source.author ? source.author.id : null;
  const authorName = source && source.author ? source.author.name : null;
  const builder = new GarminBuilder();
  builder.setMetadata(new Metadata(_objectSpread$1({}, authorName ? {
    author: new Person({
      name: authorName
    })
  } : {}, {
    link: new Link('http://www.endomondo.com', {
      text: 'Endomondo'
    }),
    time: workout.getStart().toJSDate()
  })));
  builder.setTracks([new Track([new Segment(convertPoints(workout.getPoints()))], _objectSpread$1({
    src: 'http://www.endomondo.com/'
  }, workoutId && authorId ? {
    link: new Link("https://www.endomondo.com/users/" + authorId + "/workouts/" + workoutId, {
      text: 'endomondo'
    })
  } : {}, {
    type: workout.getSportName()
  }))]);
  return buildGPX(builder.toObject());
});

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
class Workout extends Workout$1 {
  constructor(options) {
    super(options);

    _defineProperty(this, "id", void 0);

    _defineProperty(this, "typeId", void 0);

    _defineProperty(this, "points", void 0);

    _defineProperty(this, "hashtags", void 0);

    _defineProperty(this, "source", void 0);

    _defineProperty(this, "message", void 0);

    this.typeId = options.typeId;
    this.points = options.points || [];
    this.privacy = options.workoutPrivacy;
    this.hashtags = options.hashtags || [];
    this.id = options.id;
    this.source = options.source;
    this.message = options.message;
    this.isRace = this.hasHashtag('race');
    this.isCommute = this.hasHashtag('work');
  }

  static fromApi(workout) {
    const {
      points,
      distance
    } = workout;
    const start = DateTime.fromISO(workout.local_start_time, {
      setZone: true
    });
    return new Workout(_objectSpread$2({
      start,
      typeId: workout.sport,
      duration: Duration.fromObject({
        seconds: workout.duration
      }),
      source: workout,
      points: points && points.points ? points.points.map(point => {
        return Point.fromApi(point, start.toFormat('z'));
      }) : [],
      ascent: workout.ascent ? unit(workout.ascent, 'm') : undefined,
      descent: workout.descent ? unit(workout.descent, 'm') : undefined,
      calories: workout.calories,
      notes: workout.message,
      mapPrivacy: workout.show_map,
      workoutPrivacy: workout.show_workout,
      id: workout.id,
      hashtags: workout.hashtags,
      avgHeartRate: workout.heart_rate_avg,
      maxHeartRate: workout.heart_rate_max,
      title: workout.title
    }, distance ? {
      distance: unit(distance, 'km')
    } : {}));
  } // eslint-disable-next-line max-params


  static get(typeId, start, duration, distance, points = [], options = {}) {
    return new Workout(_objectSpread$2({}, options, {
      start,
      duration,
      distance,
      points,
      typeId,
      id: undefined,
      source: undefined
    }));
  }

  clone(extension) {
    return new Workout(_objectSpread$2({}, this.toObject(), {}, extension));
  }

  getId() {
    return this.id;
  }

  setId(id) {
    return this.clone({
      id
    });
  }

  getTypeId() {
    return this.typeId;
  }

  getSportName() {
    return Workout.SPORT_NAMES[this.getTypeId()];
  }

  getPoints() {
    return this.points;
  }

  getWorkoutPrivacy() {
    return this.privacy;
  }

  setWorkoutPrivacy(workoutPrivacy) {
    return this.clone({
      workoutPrivacy
    });
  }

  getMessage() {
    return this.message;
  }

  setMessage(message) {
    return this.clone({
      message
    });
  }

  setHashtags(hashtags) {
    return this.clone({
      hashtags
    });
  }

  addHashtags(hashtags) {
    return this.clone({
      hashtags: [...this.getHashtags(), ...hashtags]
    });
  }

  addHashtag(hashtag) {
    return this.addHashtags([hashtag]);
  }

  removeHashtag(hashtag) {
    return this.removeHashtags([hashtag]);
  }

  removeHashtags(hashtags) {
    return this.clone({
      hashtags: hashtags.filter(hashtag => hashtags.includes(hashtag))
    });
  }

  getSource() {
    return this.source;
  }

  toGpx() {
    return workoutGPXExporter(this);
  }

  hasGPSData() {
    return this.points.length > 0;
  }

  setTypeId(typeId) {
    return this.clone({
      typeId
    });
  }

  setStart(start) {
    return this.clone({
      start
    });
  }

  setDuration(duration) {
    return this.clone({
      duration
    });
  }

  setDistance(distance) {
    return this.clone({
      distance
    });
  }

  setPoints(points) {
    return this.clone({
      points
    });
  }

  setCalories(calories) {
    return this.clone({
      calories
    });
  }

  setNotes(notes) {
    return this.clone({
      notes
    });
  }

  setAvgHeartRate(avgHeartRate) {
    return this.clone({
      avgHeartRate
    });
  }

  setMaxHeartRate(maxHeartRate) {
    return this.clone({
      maxHeartRate
    });
  }

  setTitle(title) {
    return this.clone({
      title
    });
  }

  setAscent(ascent) {
    return this.clone({
      ascent
    });
  }

  setDescent(descent) {
    return this.clone({
      descent
    });
  }

  toObject() {
    return _objectSpread$2({}, super.toObject(), {
      typeId: this.typeId,
      points: this.points,
      mapPrivacy: this.mapPrivacy,
      workoutPrivacy: this.privacy,
      hashtags: this.hashtags,
      id: this.id,
      source: this.source,
      message: this.message
    });
  }

}

_defineProperty(Workout, "SPORT_NAMES", LIST_OF_SPORT_NAMES);

_defineProperty(Workout, "SPORT", SPORT);

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
class Api extends CookieApi {
  constructor(csfrtoken = '123456789') {
    super(ENDOMONDO_URL, [new DefaultResponseProcessor(EndomondoApiException)]);

    _defineProperty(this, "userId", null);

    _defineProperty(this, "userToken", null);

    _defineProperty(this, "csfrtoken", void 0);

    _defineProperty(this, "dateFormat", 'yyyy-MM-dd\'T\'HH:mm:ss\'.000Z\'');

    this.csfrtoken = csfrtoken;
    this.setDefaultHeaders({
      'content-type': 'application/json;charset=UTF-8',
      'x-csrf-token': this.csfrtoken,
      cookie: "CSRF_TOKEN=" + this.csfrtoken + ";"
    });
  }

  setUserId(id) {
    this.userId = id;
  }

  getUserId() {
    return this.userId;
  }

  setUserToken(token) {
    this.userToken = token;
    this.setDefaultHeader('cookie', Api.serializeCookies(_objectSpread$3({
      CSRF_TOKEN: this.csfrtoken
    }, token ? {
      USER_TOKEN: token
    } : {})));
  }

  getUserToken() {
    return this.userToken;
  }
  /**
   * Converting date to string for GET requests.
   *
   * @param date
   * @returns {string}
   */


  getDateString(date) {
    return date.toUTC().toFormat(this.dateFormat);
  }
  /**
   * Get api url for user namespace.
   */


  async getUserApiUrl(namespace, userId = this.userId) {
    if (!userId) {
      throw new EndomondoException('User id is not defined');
    }

    return "rest/v1/users/" + userId + "/" + namespace;
  }
  /**
   * Get api url for workout namespace.
   */


  async getWorkoutsApiUrl(namespace, workoutId, userId = this.userId) {
    return this.getUserApiUrl("workouts/" + (workoutId ? "" + workoutId + (namespace ? "/" + namespace : '') : namespace), userId);
  }
  /**
   * Log user to Endomondo and set user id and user token.
   *
   * @param email
   * @param password
   * @returns {Promise<string>} return user token
   */


  async login(email, password) {
    const response = await this.post('rest/session', {
      email,
      password,
      remember: true
    });
    this.setUserId(response.data.id);
    const cookies = this.getCookies();

    if (!cookies) {
      throw new EndomondoException('Cookies are missing in response.');
    }

    this.setUserToken(cookies.USER_TOKEN);
    return cookies.USER_TOKEN;
  }

  async getProfile(userId = this.userId) {
    const {
      data
    } = await this.get((await this.getUserApiUrl('')));
    return data;
  }

  async getWorkout(workoutId, userId = this.userId) {
    const response = await this.get((await this.getWorkoutsApiUrl('', workoutId, userId)));
    return Workout.fromApi(response.data);
  }

  async getWorkoutGpx(workoutId, userId = this.userId) {
    const {
      data
    } = await this.get((await this.getWorkoutsApiUrl('export?format=GPX', workoutId, userId)));
    return data;
  }

  async getWorkoutTcx(workoutId, userId = this.userId) {
    const {
      data
    } = await this.get((await this.getWorkoutsApiUrl('export?format=TCX', workoutId, userId)));
    return data;
  }

  async editWorkout(workout, userId = this.userId) {
    const distance = workout.getDistance();
    const ascent = workout.getAscent();
    const descent = workout.getDescent();
    return this.put((await this.getWorkoutsApiUrl('', workout.getId(), userId)), _objectSpread$3({
      duration: workout.getDuration().as('seconds'),
      sport: workout.getTypeId(),
      start_time: this.getDateString(workout.getStart())
    }, distance != null ? {
      distance: distance.toNumber('km')
    } : {}, {}, workout.getAvgHeartRate() != null ? {
      heart_rate_avg: workout.getAvgHeartRate()
    } : {}, {}, workout.getMaxHeartRate() != null ? {
      heart_rate_max: workout.getMaxHeartRate()
    } : {}, {}, workout.getTitle() != null ? {
      title: workout.getTitle()
    } : {}, {}, ascent != null ? {
      ascent: ascent.toNumber('m')
    } : {}, {}, descent != null ? {
      descent: descent.toNumber('m')
    } : {}, {}, workout.getMessage() != null ? {
      message: workout.getMessage()
    } : {}, {}, workout.getMapPrivacy() != null ? {
      show_map: workout.getMapPrivacy()
    } : {}, {}, workout.getWorkoutPrivacy() != null ? {
      show_workout: workout.getWorkoutPrivacy()
    } : {}));
  }

  async deleteWorkout(workoutId, userId = this.userId) {
    return this.delete((await this.getWorkoutsApiUrl('', workoutId, userId)));
  }

  async addHashtag(hashtag, workoutId, userId = this.userId) {
    return this.post((await this.getWorkoutsApiUrl("hashtags/" + hashtag, workoutId, userId)));
  }

  async removeHashtag(hashtag, workoutId, userId = this.userId) {
    return this.delete((await this.getWorkoutsApiUrl("hashtags/" + hashtag, workoutId, userId)));
  }

  async getWorkouts(filter = {}, userId = this.userId) {
    const {
      after,
      before,
      fromDuration,
      toDuration
    } = filter;
    const response = await this.get((await this.getWorkoutsApiUrl('history', null, userId)), _objectSpread$3({
      expand: 'points,workout'
    }, filter, {}, after != null ? {
      after: typeof after === 'string' ? after : this.getDateString(after)
    } : {}, {}, before != null ? {
      before: typeof before === 'string' ? before : this.getDateString(before)
    } : {}, {}, fromDuration != null ? {
      fromDuration: typeof fromDuration === 'number' ? fromDuration : fromDuration.as('seconds')
    } : {}, {}, toDuration != null ? {
      toDuration: typeof toDuration === 'number' ? toDuration : toDuration.as('seconds')
    } : {}));
    return {
      paging: response.data.paging,
      workouts: response.data.data.map(workout => {
        return Workout.fromApi(workout);
      })
    };
  }

  async processWorkouts(filter = {}, processor, userId = this.userId) {
    const {
      workouts,
      paging
    } = await this.getWorkouts(filter, userId);
    const processorPromises = workouts.map(workout => {
      return processor(workout);
    });

    if (workouts.length > 0) {
      const data = parseUrl(paging.next).query;
      processorPromises.push(...(await this.processWorkouts(data, processor, userId)).map(async workout => {
        return workout;
      }));
    }

    return Promise.all(processorPromises);
  }

}

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function processStringResponse(response) {
  const data = {};
  response.split('\n').map(item => item.split('=')).filter(item => item.length === 2).forEach(item => {
    const [key, value] = item;
    data[key] = value;
  });
  return data;
}

function gzipRequestBody(body) {
  return new Promise((resolve, reject) => {
    gzip(body, (error, buffer) => {
      if (error) {
        reject(error);
        return;
      }

      resolve(buffer);
    });
  });
}

class MobileApi extends Api$1 {
  constructor() {
    super(ENDOMONDO_MOBILE_URL, [async (response, request) => {
      const contentType = response.headers.get('content-type');
      const toResponse = {
        data: contentType && contentType.includes('json') ? await response.json() : await response.text(),
        status: response.status,
        source: response,
        request
      };

      if (typeof toResponse.data === 'object' && toResponse.data.error || !response.ok) {
        if (toResponse.data.error && toResponse.data.error.type === 'AUTH_FAILED') {
          throw new EndomondoAuthException(toResponse);
        }

        throw new EndomondoApiException(toResponse);
      }

      return toResponse;
    }], {
      'Content-Type': 'application/octet-stream',
      'User-Agent': 'Dalvik/1.4.0 (Linux; U; Android 4.1; GT-B5512 Build/GINGERBREAD)'
    });

    _defineProperty(this, "authToken", void 0);

    _defineProperty(this, "userId", void 0);

    this.authToken = null;
    this.userId = null;
  }

  getUserToken() {
    return this.authToken;
  }

  setUserToken(authToken) {
    this.authToken = authToken;
  }

  getUserId() {
    return this.userId;
  }

  setUserId(id) {
    this.userId = id;
  }

  async login(email, password) {
    const options = {
      email,
      password,
      country: '',
      deviceId: null,
      action: 'PAIR'
    };
    const response = await this.post("auth" + Api$1.convertParametersToUrl(options));
    const decoded = processStringResponse(response.data);

    if (!decoded.userId || !decoded.authToken) {
      throw new EndomondoException("User id and token was not found in response: " + response.data);
    }

    const {
      userId,
      authToken
    } = decoded;
    this.setUserId(Number(userId));
    this.setUserToken(authToken);
    return authToken;
  }

  async getProfile() {
    return this.get('api/workouts', {
      authToken: this.getUserToken()
    });
  }
  /**
   * Create Endomondo workout.
   *
   * @param workout
   * @returns {Promise<number>} return id of new workout
   */


  async createWorkout(workout) {
    const options = {
      workoutId: "-" + 'XXXXXXXXXXXXXXXX'.split('X').map(() => {
        return Math.floor(Math.random() * 9);
      }).join(''),
      duration: workout.getDuration().as('seconds'),
      sport: workout.getTypeId(),
      extendedResponse: true,
      gzip: true,
      authToken: this.getUserToken()
    };
    const gzippedBody = await gzipRequestBody(workout.getPoints().map(point => point.toString()).join('\n'));
    const response = await this.request("track" + Api$1.convertParametersToUrl(options), 'POST', {
      body: gzippedBody
    });

    if (response.data.trim() === 'AUTH_FAILED') {
      throw new EndomondoAuthException(response);
    }

    const workoutId = processStringResponse(response.data)['workout.id'];

    if (!workoutId) {
      throw new EndomondoException('Error while creating workout. Endomondo did not returned workout id.');
    }

    const numberedWorkoutId = Number(workoutId);
    await this.updateWorkout(workout.setId(numberedWorkoutId));
    return numberedWorkoutId;
  }

  async updateWorkout(workout) {
    const distance = workout.getDistance();

    const data = _objectSpread$4({
      duration: workout.getDuration().as('seconds'),
      sport: workout.getTypeId(),
      start_time: workout.getStart().toUTC().toFormat(MobileApi.dataFormat),
      end_time: workout.getStart().toUTC().toFormat(MobileApi.dataFormat),
      extendedResponse: true,
      gzip: true
    }, distance != null ? {
      distance: distance.toNumber('km')
    } : {}, {}, workout.getCalories() != null ? {
      calories: workout.getCalories()
    } : {}, {}, workout.getMessage() != null ? {
      message: workout.getMessage()
    } : {}, {}, workout.getMapPrivacy() != null ? {
      privacy_map: workout.getMapPrivacy()
    } : {}, {}, workout.getWorkoutPrivacy() != null ? {
      privacy_workout: workout.getWorkoutPrivacy()
    } : {});

    const options = {
      workoutId: workout.getId(),
      userId: this.getUserId(),
      gzip: true,
      authToken: this.getUserToken()
    };
    return this.request("api/workout/post" + Api$1.convertParametersToUrl(options), 'POST', {
      body: await gzipRequestBody(JSON.stringify(data))
    });
  }

}

_defineProperty(MobileApi, "dataFormat", 'yyyy-MM-dd HH:mm:ss \'UTC\'');

export { Api, MobileApi };
