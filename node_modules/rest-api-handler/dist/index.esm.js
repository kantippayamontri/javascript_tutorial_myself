import _defineProperty from '@babel/runtime/helpers/defineProperty';

// processor can be instance of class

/**
 * Resolve given processor.
 *
 * @param response - Response to process.
 * @param list - Array of processors.
 * @param request - fetch request
 * @param i - Index of current processor.
 * @returns Processed response
 */
async function resolveProcessors(response, list, request, i = 0) {
  const processor = list[i];

  if (!processor) {
    return response;
  }

  const processedResponse = typeof processor === 'function' ? await processor(response, request) : await processor.processResponse(response, request);

  if (list[i + 1]) {
    return resolveProcessors(processedResponse, list, request, i + 1);
  }

  return processedResponse;
}

/**
 * @desc Types of formats of data you can send through body of Fetch request.
 */

/**
 * @desc Json is object converted to string. It is default format in a library.
 */
const JSON$1 = 'json';
/**
 * @desc Form Data can be used to send images.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/FormData
 */

const FORM_DATA = 'formdata';
/**
 * @desc Url encoded data in body
 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST
 */

const URL_ENCODED = 'urlencoded';

var FORMATS = ({
    __proto__: null,
    JSON: JSON$1,
    FORM_DATA: FORM_DATA,
    URL_ENCODED: URL_ENCODED
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Class for handling responses and requests.
 */
class Api {
  /**
   * Base api url
   */

  /**
   * Base http headers
   */

  /**
   * Base settings for Fetch Request
   */

  /**
   * List of processors that parse response from server.
   */

  /**
   * List of formatter you can use to process content of body request.
   */

  /**
   * Constructor.
   *
   * @param apiUrl - Base api url
   * @param processors - List of processors that parse response from server.
   * @param defaultHeaders - Base settings for Fetch Request
   * @param defaultOptions - List of processors that parse response from server.
   */
  constructor(apiUrl, processors = [], defaultHeaders = {}, defaultOptions = {}) {
    _defineProperty(this, "apiUrl", void 0);

    _defineProperty(this, "defaultHeaders", void 0);

    _defineProperty(this, "defaultOptions", void 0);

    _defineProperty(this, "processors", void 0);

    this.apiUrl = apiUrl;
    this.defaultHeaders = defaultHeaders;
    this.defaultOptions = defaultOptions;
    this.processors = processors;
  }
  /**
   * Convert data in object to format of Fetch body.
   *
   * @param data - Data to convert
   * @param to - Format to which convert the data. Default is JSON.
   * @returns Converted data
   *
   * @example
   * const body = Api.convertData({ a: 'b' }, Api.FORMATS.JSON);
   * // output is {"a":"b"}
   */


  static convertData(data, to = JSON$1) {
    if (to === FORM_DATA) {
      const formData = new FormData();
      Object.entries(data).forEach(([key, value]) => {
        formData.append(key, value);
      });
      return formData;
    }

    if (to === URL_ENCODED) {
      return Api.convertParametersToUrl(data).slice(1);
    }

    return JSON.stringify(data);
  }
  /**
   * Convert object to url parameters string.
   *
   * @param parameters - List of parameters
   * @returns Encoded string with ? prefix and variables separated by &
   *
   * @example
   * const parameters = Api.convertData({ a: '%b%' });
   * // output is ?a=%25b%25
   */


  static convertParametersToUrl(parameters) {
    const keys = Object.keys(parameters);

    if (keys.length === 0) {
      return '';
    }

    return "?" + keys.map(key => {
      return key + "=" + encodeURIComponent(parameters[key]);
    }).join('&');
  }
  /**
   * Set default headers.
   *
   * @param headers - HTTP headers
   */


  setDefaultHeaders(headers) {
    this.defaultHeaders = headers;
  }
  /**
   * Add default HTTP header.
   *
   * @param name - Name of header
   * @param value - Value for header
   * @example
   * api.setDefaultHeader('content-type', 'application/json');
   */


  setDefaultHeader(name, value) {
    this.defaultHeaders[name] = value;
  }
  /**
   * Remove default header.
   *
   * @param name - Name of header
   */


  removeDefaultHeader(name) {
    delete this.defaultHeaders[name];
  }
  /**
   * Get default headers.
   *
   * @returns Get Default headers
   */


  getDefaultHeaders() {
    return this.defaultHeaders;
  }
  /**
   * Fetch API url.
   *
   * @protected
   * @param request - Fetch request
   * @returns Fetch response
   */


  fetchRequest(request) {
    return fetch(request);
  }
  /**
   * Request given API endpoint.
   *
   * @param namespace - Api endpoint or full url
   * @param method - Request method eg. POST or GET
   * @param options - Fetch options
   * @param headers - Custom headers
   * @returns processed response
   * @example
   * const { data } = await api.request('ad', 'POST', {
   *     body: '{"ad":1}'
   * })
   *
   * const { data } = await api.request('http://i-can-request-full-url.com/?a=b', 'GET')
   */


  async request(namespace, method, options = {}, headers = {}) {
    const urlToRequest = namespace.indexOf('http') === 0 ? namespace : this.apiUrl + "/" + namespace; // eslint-disable-next-line compat/compat

    const request = new Request(urlToRequest, _objectSpread({}, this.defaultOptions, {
      method,
      // @ts-ignore
      headers: new Headers(_objectSpread({}, this.getDefaultHeaders(), {}, headers))
    }, options));
    const response = await this.fetchRequest(request);
    return resolveProcessors(response, this.processors, request);
  }
  /**
   * Send a request with body.
   *
   * @protected
   * @param namespace - api endpoint
   * @param method - api method
   * @param data - body JSON parameters
   * @param format - format of body request
   * @param headers - custom headers
   * @returns processed response
   */


  requestWithBody(namespace, method, data, format, headers = {}) {
    return this.request(namespace, method, {
      body: Api.convertData(data, format)
    }, headers);
  }
  /**
   * Send a GET request.
   *
   * @param namespace - api endpoint
   * @param parameters - get parameters
   * @param headers - custom headers
   * @returns processed response
   *
   * @example
   * const { data } = await api.get('brand', { id: 5 })
   * // will call YOUR_URI/brand?id=5
   * console.log(data);
   */


  get(namespace, parameters = {}, headers = {}) {
    return this.request("" + namespace + Api.convertParametersToUrl(parameters), 'GET', {}, headers);
  }
  /**
   * Send a POST request.
   *
   * @param namespace - Api endpoint
   * @param data - Request object
   * @param format - Format of body request
   * @param headers - custom headers
   * @returns Processed response
   */


  post(namespace, data = {}, format = JSON$1, headers = {}) {
    return this.requestWithBody(namespace, 'POST', data, format, headers);
  }
  /**
   * Send a PUT request.
   *
   * @param namespace - Api endpoint
   * @param data - Request object
   * @param format - Format of body request
   * @param headers - custom headers
   * @returns Processed response
   */


  put(namespace, data = {}, format = JSON$1, headers = {}) {
    return this.requestWithBody(namespace, 'PUT', data, format, headers);
  }
  /**
   * Send a DELETE request.
   *
   * @param namespace - Api endpoint
   * @param headers - custom headers
   * @returns Processed response
   */


  delete(namespace, headers = {}) {
    return this.request(namespace, 'DELETE', {}, headers);
  }

}

_defineProperty(Api, "FORMATS", FORMATS);

/**
 * Processor provider that process response from API and throw custom Exception.
 */
class DefaultResponseProcessor {
  /**
   * Constructor.
   *
   * @param Exception - Exception class that will be throwed if request fails.
   * @param decoder - Define custom response body decoder.
   */
  constructor(Exception, decoder) {
    _defineProperty(this, "Exception", void 0);

    _defineProperty(this, "decoder", void 0);

    this.Exception = Exception;
    this.decoder = decoder || DefaultResponseProcessor.decodeResponse;
  }

  async processResponse(response, request) {
    const decodedResponse = await this.decoder(response);
    const toRespond = {
      data: decodedResponse,
      status: response.status,
      source: response,
      request
    };

    if (!response.ok) {
      throw new this.Exception(toRespond, request);
    }

    return toRespond;
  }

  static decodeResponse(response) {
    const contentType = response.headers.get('content-type'); // on default decode response as text

    if (!contentType) {
      return response.text();
    }

    if (contentType.includes('json')) {
      return response.json();
    }

    if (contentType.includes('text') || contentType.includes('xml')) {
      return response.text();
    }

    return response.blob();
  }

}

/* eslint-disable no-proto */

/**
 * Default API Exception
 */
class DefaultApiException extends Error {
  /**
   * Response from server that throwed an error.
   */

  /**
   * Constructor.
   *
   * @param response - Processed response from server.
   */
  constructor(response) {
    super("Api exception: " + JSON.stringify(response.data));

    _defineProperty(this, "response", void 0);

    this.response = response;
  }

  getResponse() {
    return this.response;
  }

  getRequest() {
    return this.response.request;
  }

}

export { Api, DefaultApiException, DefaultResponseProcessor };
